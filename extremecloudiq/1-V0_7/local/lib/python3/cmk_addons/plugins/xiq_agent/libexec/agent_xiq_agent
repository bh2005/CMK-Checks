#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# /opt/omd/sites/test/local/lib/python3/cmk_addons/plugins/xiq_agent/libexec/agent_xiq_agent

import sys
import argparse
import requests
import time
import os
import json
from typing import List, Dict, Any


def parse_args():
    parser = argparse.ArgumentParser(description="Extreme Cloud IQ Special Agent")
    parser.add_argument("--url", default="https://api.extremecloudiq.com", help="API Base URL")
    parser.add_argument("--username", required=True)
    parser.add_argument("--password", required=True)
    parser.add_argument("--host", required=True, help="Checkmk Hostname for caching")
    parser.add_argument("--timeout", type=int, default=60, help="Request timeout in seconds")
    parser.add_argument("--no-cert-check", action="store_true", help="Disable SSL certificate verification")
    return parser.parse_args()


class XIQClient:
    def __init__(self, args):
        self.base_url = args.url.rstrip('/')
        self.username = args.username
        self.password = args.password
        self.timeout = args.timeout
        self.verify = not args.no_cert_check

        # Cache Pfad
        omd_root = os.environ.get("OMD_ROOT", "/tmp")
        self.cache_file = f"{omd_root}/tmp/check_mk/cache/extreme_cloud_iq_{args.host}.json"
        self.token = self._load_cache()

        # Proxy hart eintragen – löst das Timeout-Problem im Monitoring
        self.proxies = {
            "http":  "http://http-proxy-ks1.k-plus-s.net:8080",
            "https": "http://http-proxy-ks1.k-plus-s.net:8080",
            "no_proxy": "127.0.0.1,localhost,10.0.0.0/8,10.127.127.39,edi.prd.k-plus-s.com,193.238.11.16,*.k-plus-s.com,*.k-plus-s.net"
        }

    def _load_cache(self) -> str | None:
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, "r") as f:
                    data = json.load(f)
                    if time.time() - data.get("timestamp", 0) < 3600:  # 1 Stunde Cache-Gültigkeit
                        return data.get("access_token")
            except Exception:
                pass
        return None

    def _save_cache(self, token: str):
        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
        with open(self.cache_file, "w") as f:
            json.dump({"access_token": token, "timestamp": time.time()}, f)
        self.token = token

    def _make_session(self) -> requests.Session:
        session = requests.Session()
        session.proxies = self.proxies
        session.verify = self.verify
        if not self.verify:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        return session

    def login(self) -> str:
        """Holt einen neuen Token via POST /login"""
        login_url = f"{self.base_url}/login"
        payload = {"username": self.username, "password": self.password}
        headers = {"Content-Type": "application/json", "Accept": "application/json"}

        session = self._make_session()
        try:
            resp = session.post(
                login_url,
                json=payload,
                headers=headers,
                timeout=self.timeout
            )
            resp.raise_for_status()
            token = resp.json().get("access_token")
            if not token:
                raise ValueError("Kein access_token in der Login-Response")
            self._save_cache(token)
            return token
        except Exception as e:
            raise RuntimeError(f"Login fehlgeschlagen: {str(e)}")

    def get_devices(self) -> List[Dict[str, Any]]:
        if not self.token:
            self.login()

        all_devices = []
        page = 1

        while True:
            session = self._make_session()
            headers = {"Authorization": f"Bearer {self.token}", "Accept": "application/json"}
            params = {"page": page, "limit": 100}

            try:
                resp = session.get(
                    f"{self.base_url}/devices",
                    headers=headers,
                    params=params,
                    timeout=self.timeout
                )

                if resp.status_code == 401:
                    self.login()
                    continue  # Retry mit neuem Token

                if resp.status_code == 429:
                    time.sleep(10)  # Rate Limit – warte 10 Sekunden
                    continue

                resp.raise_for_status()
                data = resp.json().get("data", [])
                if not data:
                    break

                all_devices.extend(data)
                if len(data) < 100:
                    break
                page += 1

            except Exception as e:
                raise RuntimeError(f"Fehler beim Abrufen der Devices (Seite {page}): {str(e)}")

        return all_devices


def main():
    args = parse_args()
    try:
        client = XIQClient(args)
        devices = client.get_devices()

        ap_count = 0
        total_clients = 0

        # Login-Status-Sektion
        print("<<<extreme_cloud_iq_login>>>")
        print("STATUS:OK CODE:200 RESPONSE:Token valid and data fetched")

        # AP-spezifische Piggyback-Sektionen
        for device in devices:
            product_type = str(device.get("product_type", "")).upper()
            if "AP" not in product_type:
                continue

            ap_count += 1
            hostname = device.get("hostname") or device.get("serial_number", "unknown")
            clients = device.get("client_count") or 0
            total_clients += clients

            print(f"<<<<{hostname}>>>>")
            print("<<<extreme_ap_status:sep(124)>>>")
            # Format: hostname|sn|mac|ip|model|is_connected|conn_state|...
            print(
                f"{hostname}|"
                f"{device.get('serial_number', 'N/A')}|"
                f"{device.get('mac_address', 'N/A')}|"
                f"{device.get('ip_address', 'N/A')}|"
                f"{device.get('product_type', 'N/A')}|"
                f"{1 if device.get('connected', False) else 0}|"
                f"{'CONNECTED' if device.get('connected', False) else 'DISCONNECTED'}|N/A|N/A"
            )

            print("<<<extreme_ap_clients:sep(124)>>>")
            print(f"{clients}|0|0")  # clients|associated|unassociated (falls du später mehr Daten hast)

            print("<<<<>>>>")

        # Summary für den Haupt-Host
        print("<<<extreme_summary:sep(124)>>>")
        print(f"access_points|{ap_count}")
        print(f"total_clients|{total_clients}")

    except Exception as e:
        print("<<<extreme_cloud_iq_login>>>")
        print(f"STATUS:FAILED CODE:ERROR RESPONSE:{str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()