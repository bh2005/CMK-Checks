#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import argparse
import requests
import json
from typing import Optional, Dict, Any

# Wir übernehmen die Defaults aus deinem Redis-Client
DEFAULT_BASE_URL = "https://api.extremecloudiq.com"

def parse_args():
    parser = argparse.ArgumentParser(description="Extreme Cloud IQ Agent for Checkmk")
    parser.add_argument("address", help="Host address (unused but required by CMK)")
    parser.add_argument("--api-token", required=True, help="XIQ API Token")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--no-cert-check", action="store_true")
    return parser.parse_args()

class XIQClient:
    def __init__(self, token: str, base_url: str, timeout: int, verify: bool):
        self.token = token
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.verify = verify
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

    def fetch_devices(self):
        # Wir nutzen exakt den Pfad aus deinem Redis-Client
        url = f"{self.base_url}/devices"
        params = {"page": 1, "limit": 100, "views": "BASIC"}
        
        try:
            response = requests.get(
                url, headers=self.headers, params=params, 
                timeout=self.timeout, verify=self.verify
            )
            response.raise_for_status()
            return response.json().get("data", [])
        except Exception as e:
            # Im Fehlerfall schreiben wir auf stderr, damit CMK-Logs es sehen, 
            # aber der Agent-Output nicht korrumpiert wird
            sys.stderr.write(f"ERROR: Failed to fetch devices: {e}\n")
            return []

def main():
    args = parse_args()
    
    # SSL Verifizierung handhaben
    verify = not args.no_cert_check
    if not verify:
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    client = XIQClient(args.api_token, DEFAULT_BASE_URL, args.timeout, verify)
    devices = client.fetch_devices()

    if not devices:
        sys.stderr.write("WARNING: No devices found or API error.\n")
        # Trotzdem leere Sektionen liefern, damit Services UNKNOWN gehen statt zu verschwinden
        print("<<<extreme_summary>>>\naccess_points=0|total_clients=0")
        return

    # 1. Piggyback Daten für jeden AP ausgeben
    total_clients = 0
    for ap in devices:
        # Extrahiere Daten
        hostname = ap.get("hostname", ap.get("serial_number", "unknown"))
        sn = ap.get("serial_number", "unknown")
        mac = ap.get("mac_address", "unknown")
        ip = ap.get("ip_address", "0.0.0.0")
        model = ap.get("model", "unknown")
        # Status: CONNECTED -> 1, sonst 0
        is_connected = 1 if ap.get("connected") is True else 0
        conn_state = "CONNECTED" if is_connected else "DISCONNECTED"
        clients = ap.get("client_count", 0)
        total_clients += clients

        # Piggyback Header
        print(f"<<<<{hostname}>>>>")
        
        # Sektion AP Status
        print("<<<extreme_ap_status:sep(124)>>>")
        # Format: hostname|serial|mac|ip|model|status|connection|sw_version|site
        print(f"{hostname}|{sn}|{mac}|{ip}|{model}|{is_connected}|{conn_state}|N/A|N/A")
        
        # Sektion AP Clients
        print("<<<extreme_ap_clients:sep(124)>>>")
        # Format: total|2.4ghz|5ghz (da BASIC view, setzen wir Funk auf 0)
        print(f"{clients}|0|0")
        
        print("<<<<>>>>")

    # 2. Summary für den Cloud-Host selbst
    print("<<<extreme_summary:sep(124)>>>")
    print(f"access_points|{len(devices)}")
    print(f"total_clients|{total_clients}")

if __name__ == "__main__":
    main()