#!/usr/bin/env python3

import os
import sys
import requests
import json
import time
import logging
import argparse

# Konfiguration
XIQ_BASE_URL = "https://api.extremecloudiq.com"
LOG_FILE = "/var/log/check_mk/xiq_agent.log"
logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
log = logging.getLogger(__name__)


def generate_xiq_api_key(username, password):
    """Generiert einen neuen XIQ API-Schlüssel."""
    url = f"{XIQ_BASE_URL}/login"
    headers = {"Content-Type": "application/json"}
    data = {"username": username, "password": password}

    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        json_response = response.json()
        api_key = json_response.get("access_token")

        if not api_key:
            log.error("Error: Could not extract API key from the response")
            return None
        return api_key

    except requests.exceptions.RequestException as e:
        log.error(f"Fehler während der API-Anfrage: {str(e)}")
        return None
    except json.JSONDecodeError as e:
        log.error(f"Fehler beim Decodieren der JSON-Antwort: {str(e)}")
        return None


def renew_token():
    """Erneuert das API-Token mithilfe gespeicherter Zugangsdaten."""
    username = os.getenv("ADMIN_MAIL")
    password = os.getenv("XIQ_PASS")

    if not username or not password:
        log.error("Umgebungsvariablen ADMIN_MAIL oder XIQ_PASS sind nicht gesetzt")
        return None

    new_api_key = generate_xiq_api_key(username, password)
    if new_api_key:
        os.environ["XIQ_API_SECRET"] = new_api_key
        log.info("API-Schlüssel wurde erfolgreich erneuert")
        return new_api_key
    else:
        log.error("Fehler beim Erneuern des API-Schlüssels")
        return None


def get_api_key():
    """Ruft das API-Token aus der Umgebungsvariable ab."""
    api_key = os.getenv("XIQ_API_SECRET")
    if not api_key:
        log.error("Umgebungsvariable XIQ_API_SECRET ist nicht gesetzt. Versuche Token zu erneuern.")
        api_key = renew_token()
        if not api_key:
            log.error("API-Token konnte nicht erneuert werden. Bitte ADMIN_MAIL und XIQ_PASS Umgebungsvariablen prüfen oder XIQ_API_SECRET manuell setzen.")
            sys.exit(1)
    return api_key


def get_xiq_data(endpoint, params=None):
    """Fragt die XIQ API ab mit verbesserter Fehlerbehandlung."""
    url = f"{XIQ_BASE_URL}{endpoint}"
    api_key = get_api_key()
    headers = {"Authorization": f"Bearer {api_key}", "Accept": "application/json"}

    try:
        response = requests.get(url, headers=headers, params=params, timeout=10) # Timeout hinzugefügt
        response.raise_for_status() # Wirft eine Exception für 4xx und 5xx Fehler
        return response.json()

    except requests.exceptions.Timeout:
        log.error(f"Timeout beim Abrufen von {url}")
        return None
    except requests.exceptions.ConnectionError as e:
        log.error(f"Verbindungsfehler beim Abrufen von {url}: {e}")
        return None
    except requests.exceptions.HTTPError as e:
        log.error(f"HTTP-Fehler beim Abrufen von {url}: {e}")
        if e.response is not None:
            log.error(f"Antworttext vom Server: {e.response.text}") #Antworttext ausgeben
        return None
    except requests.exceptions.RequestException as e:
        log.error(f"Allgemeiner Fehler beim Abrufen von {url}: {e}")
        return None
    except json.JSONDecodeError as e:
        log.error(f"Fehler beim Decodieren der JSON-Antwort von {url}: {e}")
        if response is not None:
            log.error(f"Fehlerhafte Antwort: {response.text}") #Antworttext ausgeben
        return None
    except Exception as e: #Fängt alle anderen Exceptions ab
        log.error(f"Unerwarteter Fehler beim Abrufen von {url}: {e}")
        return None
    
def format_uptime(uptime_unix):
    """Formatiert die Uptime basierend auf dem UNIX-Zeitstempel."""
    if not isinstance(uptime_unix, (int, float)):
        return None

    try:
        current_time = int(time.time())
        uptime_s = current_time - int(uptime_unix)

        if uptime_s < 0:
            return "Zeitstempel liegt in der Zukunft"

        uptime_m = uptime_s // 60
        uptime_h = uptime_m // 60
        uptime_d = uptime_h // 24

        if uptime_d > 2000:
            return "Offline"

        s = uptime_s % 60
        m = uptime_m % 60
        h = uptime_h % 24

        return f"{uptime_d} Tage, {h:02} Stunden, {m:02} Minuten, {s:02} Sekunden"
    except TypeError:
        return None



def main():
    parser = argparse.ArgumentParser(description="Checkmk Spezialagent für ExtremeCloud IQ.")
    parser.add_argument("hostname", help="Hostname für Checkmk")
    parser.add_argument("username", help="ExtremeCloud IQ Benutzername")
    args = parser.parse_args()

    api_key = get_api_key()

    devices = get_xiq_data("/devices", params={"limit": 1000})
    if devices:
        print("<<<xiq_devices>>>")
        for device in devices.get("data", []):
            uptime = format_uptime(device.get("system_up_time"))
            device["system_up_time_formatted"] = uptime #Fügt formatierte Uptime zum Device hinzu
            print(json.dumps(device))
        print(f"<<<xiq_devices_count>>>\ndevice_count {devices.get('totalCount', 0)}")
    else:
        print("<<<xiq_devices>>>")
        print("Error fetching devices or no devices found.")

if __name__ == "__main__":
    main()
