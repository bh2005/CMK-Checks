#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Special Agent: agent_xiq (ExtremeCloudIQ → Checkmk)
Compatible with Checkmk 2.3 / 2.4

Features:
- Token cache (1h), re-login on 401
- Backoff on 429 (rate limit)
- Device fetch (/devices FULL) with paging
- Radio information per AP with robust fallbacks
- Piggyback *only* for APs managed by XIQ (device_function=="AP" AND managed_by=="XIQ")
- Inventory & neighbors on main host (H1)

Sections printed on H1:
  <<<extreme_cloud_iq_login>>>
  <<<extreme_cloud_iq_rate_limits:sep(124)>>>
  <<<extreme_summary:sep(124)>>>
  <<<extreme_device_inventory:sep(124)>>>
  <<<extreme_device_neighbors:sep(124)>>>

Per AP (piggyback):
  <<<extreme_ap_status:sep(124)>>>
  <<<extreme_ap_clients:sep(124)>>>
  <<<xiq_radio_information:json>>>
"""

from __future__ import annotations
import argparse
import json
import os
import sys
import time
from typing import Any, Dict, List, Optional, Tuple

import requests


# ---------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------
def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Checkmk Special Agent for ExtremeCloud IQ")
    p.add_argument("--url", default="https://api.extremecloudiq.com", help="API Base URL")
    p.add_argument("--username", required=True, help="API Username")
    p.add_argument("--password", required=True, help="API Password")
    p.add_argument("--timeout", type=int, default=30, help="HTTP timeout")
    p.add_argument("--host", required=True, help="Checkmk host name (Haupt-Host)")
    p.add_argument("--no-cert-check", action="store_true", help="Disable TLS verification")
    p.add_argument("--proxy", default=None, help="Proxy http://proxy:8080")
    return p.parse_args()


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------
def _safe_int(v: Any, default: int = 0) -> int:
    try:
        if v is None:
            return default
        return int(v)
    except Exception:
        return default


def _format_mac(raw: str) -> str:
    r = (raw or "").replace(":", "").replace("-", "").strip().upper()
    if len(r) != 12:
        return raw or ""
    return ":".join(r[i:i+2] for i in range(0, 12, 2))


def _shorten_location(locations: Any) -> str:
    if not locations:
        return ""
    try:
        names: List[str] = []
        for e in locations:
            if isinstance(e, str):
                names.append(e)
            elif isinstance(e, dict):
                names.append(e.get("name") or e.get("path") or str(e.get("id", "")))
        names = [n for n in names if n]
        return " / ".join(names[:5]) if names else ""
    except Exception:
        return ""


def _band_clients(dev: Dict[str, Any]) -> Tuple[int, int, int]:
    """Tries to consolidate band client counts from mixed device structures."""
    c24 = _safe_int(dev.get("active_clients_24") or dev.get("clients_24") or dev.get("client_count_24"))
    c5  = _safe_int(dev.get("active_clients_5")  or dev.get("clients_5")  or dev.get("client_count_5"))
    c6  = _safe_int(dev.get("active_clients_6")  or dev.get("clients_6")  or dev.get("client_count_6"))

    radios = dev.get("radios") or dev.get("radio_list") or []
    try:
        for r in radios:
            band = str(r.get("band") or r.get("radioBand") or "").lower()
            rc = _safe_int(r.get("active_clients") or r.get("connected_clients") or r.get("client_count"))
            if band.startswith("2"):
                c24 += rc
            elif band.startswith("5"):
                c5 += rc
            elif band.startswith("6"):
                c6 += rc
    except Exception:
        pass

    return c24, c5, c6


# ---------------------------------------------------------------------
# Session / Cache
# ---------------------------------------------------------------------
def _mk_session(verify: bool, proxy: Optional[str]) -> requests.Session:
    s = requests.Session()
    s.verify = verify
    if proxy:
        s.proxies = {"http": proxy, "https": proxy}
    if not verify:
        try:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        except Exception:
            pass
    return s


def _cache_path(site_host: str) -> str:
    omd_root = os.environ.get("OMD_ROOT", "/tmp")
    path = os.path.join(omd_root, "var", "check_mk", "special_agents", "xiq")
    os.makedirs(path, exist_ok=True)
    return os.path.join(path, f"{site_host}.json")


def _cache_load(cf: str) -> Optional[str]:
    try:
        with open(cf, "r", encoding="utf-8") as f:
            data = json.load(f)
        if time.time() - data.get("ts", 0) < 3600:
            return data.get("access_token")
    except Exception:
        pass
    return None


def _cache_save(cf: str, token: str) -> None:
    tmp = cf + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump({"access_token": token, "ts": time.time()}, f)
    os.replace(tmp, cf)


# ---------------------------------------------------------------------
# API
# ---------------------------------------------------------------------
def api_login(base_url: str, username: str, password: str, timeout: int,
              verify: bool, proxy: Optional[str], cachefile: str) -> str:
    s = _mk_session(verify, proxy)
    url = f"{base_url.rstrip('/')}/login"
    r = s.post(url, json={"username": username, "password": password}, timeout=timeout)
    r.raise_for_status()
    token = r.json().get("access_token")
    if not token:
        raise RuntimeError("Login response contained no access_token")
    _cache_save(cachefile, token)
    return token


def api_request_json(base_url: str, path: str, token: str, timeout: int,
                     verify: bool, proxy: Optional[str], method: str = "GET",
                     params: Optional[Dict[str, Any]] = None):
    url = f"{base_url.rstrip('/')}{path}"
    params = params or {}

    for attempt in range(5):
        try:
            s = _mk_session(verify, proxy)
            headers = {"Authorization": f"Bearer {token}"}
            r = s.request(method, url, headers=headers, params=params, timeout=timeout)

            if r.status_code == 401:
                return "RELOGIN", None, r
            if r.status_code == 429:
                # exponential-ish backoff, capped
                time.sleep(min(30, 5 * (attempt + 1)))
                continue

            r.raise_for_status()
            try:
                return "OK", r.json(), r
            except ValueError:
                return "OK", None, r

        except requests.exceptions.Timeout:
            time.sleep(2)
        except Exception:
            time.sleep(1)

    return "ERROR", None, None


# ---------------------------------------------------------------------
# Rate Limits
# ---------------------------------------------------------------------
def fetch_rate_limits(base_url: str, token: str, timeout: int,
                      verify: bool, proxy: Optional[str]) -> Tuple[bool, Dict[str, Any]]:
    status, _json, resp = api_request_json(
        base_url,
        "/devices",
        token,
        timeout,
        verify,
        proxy,
        params={"page": 1, "limit": 1, "views": "ID", "async": "false"},
    )

    if not resp:
        return False, {"state": "NO_RESPONSE"}

    limit = resp.headers.get("RateLimit-Limit")
    remaining = resp.headers.get("RateLimit-Remaining")
    reset = resp.headers.get("RateLimit-Reset")

    if limit is not None or remaining is not None:
        return True, {
            "state": "OK",
            "limit": int(limit) if limit else None,
            "remaining": int(remaining) if remaining else None,
            "reset_in_seconds": int(reset) if reset else None,
        }

    return True, {
        "state": "UNLIMITED",
        "limit": None,
        "remaining": None,
        "reset_in_seconds": None,
    }


# ---------------------------------------------------------------------
# DEVICE FETCH
# ---------------------------------------------------------------------
def get_devices(base_url: str, token: str, timeout: int,
                verify: bool, proxy: Optional[str]) -> Tuple[str, Optional[List[Dict[str, Any]]]]:
    devices: List[Dict[str, Any]] = []
    page = 1

    base_params = {
        "limit": 100,
        "connected": "true",
        "order": "ASC",
        "views": "FULL",
        "deviceTypes": "REAL",
        "async": "false",
    }

    while True:
        params = dict(base_params)
        params["page"] = page

        status, data_json, resp = api_request_json(
            base_url, "/devices", token, timeout, verify, proxy, params=params
        )

        if status == "RELOGIN":
            return "RELOGIN", None
        if status != "OK":
            return "ERROR", None

        chunk = data_json.get("data", []) if data_json else []
        if not chunk:
            break

        devices.extend(chunk)

        if len(chunk) < base_params["limit"]:
            break

        page += 1
        if page > 10000:
            break

    return "OK", devices


# ---------------------------------------------------------------------
# RADIO INFORMATION – ROBUST (WITH FALLBACKS)
# ---------------------------------------------------------------------
def _extract_radios_from_payload(payload: Any, device_id: Any) -> List[Dict[str, Any]]:
    """
    Accept both:
      - paged envelope: {"data":[{"device_id":..., "radios":[...]}], ...}
      - plain list: [{"device_id":..., "radios":[...]}]
    Return radios for the given device_id.
    """
    did = str(device_id)
    radios: List[Dict[str, Any]] = []

    if not payload:
        return radios

    # Variant A: dict with "data"
    if isinstance(payload, dict) and isinstance(payload.get("data"), list):
        for entry in payload.get("data") or []:
            try:
                if str(entry.get("device_id")) == did:
                    radios.extend(entry.get("radios", []) or [])
            except Exception:
                continue
        if radios:
            return radios

    # Variant B: plain list
    if isinstance(payload, list):
        for entry in payload:
            try:
                if str(entry.get("device_id")) == did:
                    radios.extend(entry.get("radios", []) or [])
            except Exception:
                continue

    return radios


def get_radio_information_for_device(
    base_url: str,
    token: str,
    timeout: int,
    verify: bool,
    proxy: Optional[str],
    device_id: int,
) -> List[Dict[str, Any]]:
    """
    Robust radio-information retrieval with multiple fallbacks:
      1) /devices/radio-information?deviceIds=<id>&page=1&limit=200&async=false
      2) /devices/radio-information?deviceIds=<id>&async=false   (no paging)
      3) /devices/<id>/radio-information?async=false              (alternate path)
    """
    def _req(params=None, path="/devices/radio-information"):
        return api_request_json(
            base_url, path, token, timeout, verify, proxy,
            params=params or {},
        )

    # Try 1: paged + async=false
    status, payload, _ = _req(params={
        "deviceIds": str(device_id),
        "page": 1,
        "limit": 200,
        "async": "false",
    })
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    # Try 2: no paging + async=false
    status, payload, _ = _req(params={
        "deviceIds": str(device_id),
        "async": "false",
    })
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    # Try 3: alternate path /devices/<id>/radio-information
    status, payload, _ = api_request_json(
        base_url, f"/devices/{device_id}/radio-information",
        token, timeout, verify, proxy, params={"async": "false"},
    )
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    return []


# ---------------------------------------------------------------------
# MAIN
# ---------------------------------------------------------------------
def main():
    args = parse_args()
    verify = not args.no_cert_check
    cachefile = _cache_path(args.host)

    # ----------------------------------------------------
    # Login with cache
    # ----------------------------------------------------
    token = _cache_load(cachefile)
    if not token:
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            sys.exit(0)

    # ----------------------------------------------------
    # Rate limits
    # ----------------------------------------------------
    ok_rl, rl_data = fetch_rate_limits(
        args.url, token, args.timeout, verify, args.proxy
    )
    if not ok_rl:
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            ok_rl, rl_data = fetch_rate_limits(
                args.url, token, args.timeout, verify, args.proxy
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            sys.exit(0)

    # Print Rate‑Limit‑Section (H1)
    print("<<<extreme_cloud_iq_rate_limits:sep(124)>>>")
    print(f"state|{rl_data.get('state')}")
    print(f"limit|{rl_data.get('limit') or ''}")
    print(f"remaining|{rl_data.get('remaining') or ''}")
    print(f"reset_in_seconds|{rl_data.get('reset_in_seconds') or ''}")

    # ----------------------------------------------------
    # Fetch devices
    # ----------------------------------------------------
    status, devices = get_devices(
        args.url, token, args.timeout, verify, args.proxy
    )
    if status == "RELOGIN":
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            status, devices = get_devices(
                args.url, token, args.timeout, verify, args.proxy
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            sys.exit(0)

    if status != "OK" or devices is None:
        print("<<<extreme_cloud_iq_login>>>")
        print("STATUS:FAILED CODE:ERROR RESPONSE:Device fetch failed")
        sys.exit(0)

    print("<<<extreme_cloud_iq_login>>>")
    print("STATUS:OK CODE:200 RESPONSE:Token valid and data fetched")

    # -----------------------------------------------------------------
    # Piggyback: only APs AND managed_by == XIQ
    # -----------------------------------------------------------------
    ap_count = 0
    total_clients = 0
    sum_24 = 0
    sum_5  = 0
    sum_6  = 0

    for dev in devices:
        dev_fun_u = (str(dev.get("device_function", "")) or "").upper()
        managed_by_u = (str(dev.get("managed_by", "")) or "").upper()

        # ---- FILTER -----------------------------
        if dev_fun_u != "AP" or managed_by_u != "XIQ":
            continue
        # ------------------------------------------

        ap_count += 1

        hostname = dev.get("hostname") or dev.get("serial_number", "unknown")
        serial   = dev.get("serial_number", "")
        mac      = _format_mac(dev.get("mac_address", ""))
        ip       = dev.get("ip_address", "")
        model    = dev.get("product_type", "")
        sw       = dev.get("software_version") or dev.get("display_version") or ""
        connected = dev.get("connected", False)
        uptime    = _safe_int(dev.get("system_up_time"), 0)
        loc       = _shorten_location(dev.get("locations"))

        # Short LLDP preview
        lldp_short = ""
        infos = dev.get("lldp_cdp_infos") or []
        if infos:
            n = infos[0]
            sysname = n.get("system_name", "")
            portid  = n.get("port_id", "")
            lldp_short = f"{sysname}/{portid}"

        # Band clients
        c24, c5, c6 = _band_clients(dev)
        total_clients += (c24 + c5 + c6)
        sum_24 += c24
        sum_5  += c5
        sum_6  += c6

        # --------------------------------------------------------
        # PIGGYBACK BLOCK START
        # --------------------------------------------------------
        print(f"<<<<{hostname}>>>>")

        # AP STATUS
        print("<<<extreme_ap_status:sep(124)>>>")
        print(
            f"{hostname}|{serial}|{mac}|{ip}|{model}|"
            f"{1 if connected else 0}|"
            f"{'CONNECTED' if connected else 'DISCONNECTED'}|"
            f"{sw}|{uptime}|{loc}|{lldp_short}"
        )

        # AP CLIENTS
        print("<<<extreme_ap_clients:sep(124)>>>")
        print(f"{c24}|{c5}|{c6}")


        # --------------------------------------------------------
        # RADIO INFORMATION (robust) + SSID-Frequenz-Zuordnung
        # --------------------------------------------------------
        radio_list = get_radio_information_for_device(
            args.url, token, args.timeout, verify, args.proxy, dev.get("id", 0)
        )
        if radio_list and isinstance(radio_list[0], dict) and radio_list[0].get("_error") == "RELOGIN":
            # Re-Login
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            radio_list = get_radio_information_for_device(
                args.url, token, args.timeout, verify, args.proxy, dev.get("id", 0)
            )
        
        # ---- NEU: Präzise SSID-Client-Counts pro Frequenz ----
        ssid_freq = {}   # Format: { "SSID": {"2.4GHz": X, "5GHz": Y, "6GHz": Z} }
        
        for r in (radio_list or []):
            # Frequenz bestimmen
            freq = str(r.get("frequency") or "").strip()
            if not freq:
                mode = str(r.get("mode") or "").lower()
                if "5g" in mode:
                    freq = "5GHz"
                elif "6g" in mode:
                    freq = "6GHz"
                else:
                    freq = "2.4GHz"
        
            # Clients dieses Radios prüfen
            clients = r.get("clients") or []
            for c in clients:
                ssid = c.get("ssid") or c.get("network_policy_name") or ""
                ssid = ssid.strip()
                if not ssid:
                    continue
        
                # Struktur initialisieren
                if ssid not in ssid_freq:
                    ssid_freq[ssid] = {"2.4GHz": 0, "5GHz": 0, "6GHz": 0}
        
                # Frequenz hochzählen
                if freq in ssid_freq[ssid]:
                    ssid_freq[ssid][freq] += 1
        
        # Ausgabe erweitern
        print("<<<xiq_radio_information:json>>>")
        print(json.dumps({
            "device_id": dev.get("id"),
            "hostname": hostname,
            "radios": radio_list or [],
            "_ssid_freq": ssid_freq,   # <<< NEU
        }, ensure_ascii=False, separators=(",", ":")))


        print("<<<<>>>>")
        # --------------------------------------------------------
        # PIGGYBACK BLOCK END
        # --------------------------------------------------------

    # -----------------------------------------------------------------
    # SUMMARY (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_summary:sep(124)>>>")
    print(f"access_points|{ap_count}")
    print(f"total_clients|{total_clients}")
    print(f"clients_24|{sum_24}")
    print(f"clients_5|{sum_5}")
    print(f"clients_6|{sum_6}")

    # -----------------------------------------------------------------
    # DEVICE INVENTORY (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_device_inventory:sep(124)>>>")
    for dev in devices:
        dev_id   = dev.get("id", "")
        hostname = dev.get("hostname") or dev.get("serial_number", "unknown")
        serial   = dev.get("serial_number", "")
        mac      = _format_mac(dev.get("mac_address", ""))
        ip       = dev.get("ip_address", "")
        model    = dev.get("product_type", "")
        sw       = dev.get("software_version") or dev.get("display_version") or ""
        dev_fun  = dev.get("device_function", "").upper() or "UNKNOWN"
        loc      = _shorten_location(dev.get("locations"))
        managed_by = dev.get("managed_by", "XIQ")

        print(
            f"{dev_id}|{hostname}|{serial}|{mac}|{ip}|{model}|{sw}|"
            f"{loc}|{dev_fun}|{managed_by}"
        )

    # -----------------------------------------------------------------
    # LLDP/CDP NEIGHBORS (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_device_neighbors:sep(124)>>>")

    def _clean(v: str) -> str:
        if not v:
            return ""
        return (
            v.replace("(interface name)", "")
             .replace("(mac address)", "")
             .strip()
        )

    for dev in devices:
        dev_id    = dev.get("id", "")
        hostname  = dev.get("hostname") or dev.get("serial_number", "unknown")
        host_ip   = dev.get("ip_address", "")

        neigh_list = dev.get("lldp_cdp_infos") or []
        if isinstance(neigh_list, dict):
            neigh_list = [neigh_list]

        for n in neigh_list:
            local_port    = _clean(n.get("interface_name", ""))
            remote_device = (n.get("system_name", "") or "").strip()
            management_ip = _clean(n.get("management_ip", ""))
            remote_port   = _clean(n.get("port_id", ""))
            port_desc     = _clean(n.get("port_description", ""))
            mac_address   = _format_mac(_clean(n.get("system_id", "")))

            print(
                f"{dev_id}|{hostname}|{host_ip}|{local_port}|{management_ip}|"
                f"{remote_port}|{port_desc}|{mac_address}|{remote_device}"
            )

    sys.exit(0)


if __name__ == "__main__":
    main()
