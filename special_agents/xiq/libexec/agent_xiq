#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Special Agent: agent_xiq (ExtremeCloudIQ -> Checkmk)
Compatible with Checkmk 2.3 / 2.4

Features:
- Token cache (1h), re-login on 401
- Backoff on 429 (rate limit)
- Device fetch (/devices FULL) with paging
- Radio information per AP with robust fallbacks
- Piggyback *only* for APs managed by XIQ (device_function=="AP" AND managed_by=="XIQ")
- Inventory & neighbors on main host (H1)

Sections printed on H1:
  <<<extreme_cloud_iq_login>>>
  <<<extreme_cloud_iq_rate_limits:sep(124)>>>
  <<<extreme_summary:sep(124)>>>
  <<<extreme_device_inventory:sep(124)>>>
  <<<extreme_device_neighbors:sep(124)>>>

Per AP (piggyback):
  <<<extreme_ap_status:sep(124)>>>
  <<<extreme_ap_clients:sep(124)>>>
  <<<xiq_radio_information:json>>>
"""

from __future__ import annotations

import argparse
import json
import os
import sys
import time
from typing import Any, Dict, List, Optional, Tuple

import requests


# ---------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------
def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Checkmk Special Agent for ExtremeCloud IQ")
    p.add_argument("--url", default="https://api.extremecloudiq.com", help="API Base URL")
    p.add_argument("--username", required=True, help="API Username")
    p.add_argument("--password", required=True, help="API Password")
    p.add_argument("--timeout", type=int, default=30, help="HTTP timeout")
    p.add_argument("--host", required=True, help="Checkmk host name (main host)")
    p.add_argument("--no-cert-check", action="store_true", help="Disable TLS verification")
    p.add_argument("--proxy", default=None, help="Proxy http://proxy:8080")
    return p.parse_args()


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------
def _safe_int(v: Any, default: int = 0) -> int:
    try:
        if v is None:
            return default
        return int(v)
    except Exception:
        return default


def _format_mac(raw: str) -> str:
    r = (raw or "").replace(":", "").replace("-", "").replace(".", "").strip().upper()
    if len(r) < 12:
        return raw or ""
    r = r[:12]
    return ":".join(r[i:i+2] for i in range(0, 12, 2))


def _clean_text(v: str) -> str:
    """Remove noisy suffixes from LLDP/CDP fields and trim."""
    if not v:
        return ""
    return (
        str(v)
        .replace("(interface name)", "")
        .replace("(mac address)", "")
        .strip()
    )


def _shorten_location(locations: Any) -> str:
    """
    Extracts ONLY the LOC code (e.g. LOC279).
    Assumes LOC usually sits in the second last element if the last is FLOOR_X.
    """
    if not locations:
        return ""

    try:
        names: List[str] = []
        for e in locations:
            if isinstance(e, str):
                names.append(e)
            elif isinstance(e, dict):
                names.append(e.get("name") or e.get("path") or str(e.get("id", "")))

        names = [n.strip() for n in names if n]
        if not names:
            return ""

        last = names[-1].upper()
        prev = names[-2].upper() if len(names) >= 2 else last

        if "LOC" in prev:
            idx = prev.rfind("LOC")
            return prev[idx:]

        if "LOC" in last:
            idx = last.rfind("LOC")
            return last[idx:]

        return prev
    except Exception:
        return ""


def _band_clients(dev: Dict[str, Any]) -> Tuple[int, int, int]:
    """Tries to consolidate band client counts from mixed device structures."""
    c24 = _safe_int(dev.get("active_clients_24") or dev.get("clients_24") or dev.get("client_count_24"))
    c5  = _safe_int(dev.get("active_clients_5")  or dev.get("clients_5")  or dev.get("client_count_5"))
    c6  = _safe_int(dev.get("active_clients_6")  or dev.get("clients_6")  or dev.get("client_count_6"))

    radios = dev.get("radios") or dev.get("radio_list") or []
    try:
        for r in radios:
            band = str(r.get("band") or r.get("radioBand") or "").lower()
            rc = _safe_int(r.get("active_clients") or r.get("connected_clients") or r.get("client_count"))
            if band.startswith("2"):
                c24 += rc
            elif band.startswith("5"):
                c5 += rc
            elif band.startswith("6"):
                c6 += rc
    except Exception:
        pass

    return c24, c5, c6


# ---------------------------------------------------------------------
# Session / Cache
# ---------------------------------------------------------------------
def _mk_session(verify: bool, proxy: Optional[str]) -> requests.Session:
    s = requests.Session()
    s.verify = verify
    if proxy:
        s.proxies = {"http": proxy, "https": proxy}
    if not verify:
        try:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        except Exception:
            pass
    return s


def _cache_path(site_host: str) -> str:
    omd_root = os.environ.get("OMD_ROOT", "/tmp")
    path = os.path.join(omd_root, "var", "check_mk", "special_agents", "xiq")
    os.makedirs(path, exist_ok=True)
    return os.path.join(path, f"{site_host}.json")


def _cache_load(cf: str) -> Optional[str]:
    try:
        with open(cf, "r", encoding="utf-8") as f:
            data = json.load(f)
        if time.time() - data.get("ts", 0) < 3600:
            return data.get("access_token")
    except Exception:
        pass
    return None


def _cache_save(cf: str, token: str) -> None:
    tmp = cf + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump({"access_token": token, "ts": time.time()}, f)
    os.replace(tmp, cf)


# ---------------------------------------------------------------------
# API
# ---------------------------------------------------------------------
def api_login(base_url: str, username: str, password: str, timeout: int,
              verify: bool, proxy: Optional[str], cachefile: str) -> str:
    s = _mk_session(verify, proxy)
    url = f"{base_url.rstrip('/')}/login"
    r = s.post(url, json={"username": username, "password": password}, timeout=timeout)
    r.raise_for_status()
    token = r.json().get("access_token")
    if not token:
        raise RuntimeError("Login response contained no access_token")
    _cache_save(cachefile, token)
    return token


def api_request_json(base_url: str, path: str, token: str, timeout: int,
                     verify: bool, proxy: Optional[str], method: str = "GET",
                     params: Optional[Dict[str, Any]] = None):
    url = f"{base_url.rstrip('/')}{path}"
    params = params or {}

    for attempt in range(5):
        try:
            s = _mk_session(verify, proxy)
            headers = {"Authorization": f"Bearer {token}"}
            r = s.request(method, url, headers=headers, params=params, timeout=timeout)

            if r.status_code == 401:
                return "RELOGIN", None, r
            if r.status_code == 429:
                time.sleep(min(30, 5 * (attempt + 1)))
                continue

            r.raise_for_status()
            try:
                return "OK", r.json(), r
            except ValueError:
                return "OK", None, r

        except requests.exceptions.Timeout:
            time.sleep(2)
        except Exception:
            time.sleep(1)

    return "ERROR", None, None


# ---------------------------------------------------------------------
# Rate Limits
# ---------------------------------------------------------------------
def _to_int_safe_str(val: Optional[str]) -> Optional[int]:
    if val is None:
        return None
    s = str(val).strip()
    if s == "":
        return None
    try:
        return int(s)
    except Exception:
        try:
            return int(float(s))
        except Exception:
            return None


def _parse_limit_header(raw: Optional[str]) -> Tuple[Optional[int], Optional[int]]:
    """
    Expects e.g. "7500;w=3600" or "7500".
    Returns (limit, window_s).
    """
    if not raw:
        return None, None
    text = str(raw).strip()
    limit_part = text
    window_s: Optional[int] = None

    if ";" in text:
        parts = [p.strip() for p in text.split(";") if p.strip()]
        limit_part = parts[0]
        for p in parts[1:]:
            if p.startswith("w="):
                window_s = _to_int_safe_str(p.split("=", 1)[1])

    limit = _to_int_safe_str(limit_part)
    return limit, window_s


def _rate_limit_from_resp(resp) -> Dict[str, Any]:
    """Extract rate-limit info and full headers from a requests.Response."""
    try:
        headers_case = dict(resp.headers)
    except Exception:
        headers_case = {}
    hdr = {k.lower(): v for k, v in headers_case.items()}

    raw_limit     = hdr.get("ratelimit-limit")     or hdr.get("x-ratelimit-limit")
    raw_remaining = hdr.get("ratelimit-remaining") or hdr.get("x-ratelimit-remaining")
    raw_reset     = hdr.get("ratelimit-reset")     or hdr.get("x-ratelimit-reset")

    limit, window_s = _parse_limit_header(raw_limit)
    remaining       = _to_int_safe_str(raw_remaining)
    reset_s         = _to_int_safe_str(raw_reset)

    d: Dict[str, Any] = {
        "state": "OK",
        "limit": limit,
        "remaining": remaining,
        "reset_in_seconds": reset_s,
        "window_s": window_s,
        "headers": headers_case,
        "status_code": getattr(resp, "status_code", None),
    }
    if all(d.get(k) is None for k in ("limit", "remaining", "reset_in_seconds", "window_s")):
        d["state"] = "UNLIMITED"
    return d


def _rate_limit_try_paths_raw(base_url: str, token: str, timeout: int, verify: bool, proxy: Optional[str]) -> Tuple[bool, Dict[str, Any]]:
    s = _mk_session(verify, proxy)
    headers = {"Authorization": f"Bearer {token}", "Connection": "keep-alive"}

    def _one(path: str) -> Tuple[bool, Dict[str, Any]]:
        url = f"{base_url.rstrip('/')}{path}"
        try:
            r = s.get(url, headers=headers, timeout=timeout, allow_redirects=False)
            if r.status_code == 401:
                return False, {"state": "RELOGIN", "status_code": r.status_code}
            info = _rate_limit_from_resp(r)
            info["status_code"] = r.status_code
            return True, info
        except requests.exceptions.Timeout as e:
            return False, {"state": "NO_RESPONSE", "error": f"timeout: {e}"}
        except requests.exceptions.ProxyError as e:
            return False, {"state": "NO_RESPONSE", "error": f"proxy_error: {e}"}
        except Exception as e:
            return False, {"state": "NO_RESPONSE", "error": f"exception: {e}"}

    # 1) /devices (often returns 400 but with headers)
    ok1, info1 = _one("/devices?page=1&limit=1&views=ID&async=false")
    if ok1:
        return True, info1
    if info1.get("state") == "RELOGIN":
        return False, info1

    # 2) /account/profile (usually 200 + headers)
    ok2, info2 = _one("/account/profile")
    if ok2:
        return True, info2
    if info2.get("state") == "RELOGIN":
        return False, info2

    # 3) /devices/radio-information
    ok3, info3 = _one("/devices/radio-information?page=1&limit=1&async=false")
    if ok3:
        return True, info3

    err = info1.get("error") or info2.get("error") or info3.get("error") or "no response on all paths"
    return False, {"state": "NO_RESPONSE", "error": err}


def fetch_rate_limits(base_url: str, token: str, timeout: int,
                      verify: bool, proxy: Optional[str]) -> Tuple[bool, Dict[str, Any]]:
    ok, data = _rate_limit_try_paths_raw(base_url, token, timeout, verify, proxy)
    if data.get("state") == "RELOGIN":
        return False, data
    if ok:
        return True, data

    # Optional fallback: JSON path ensures a Response object
    try:
        status, _json, resp = api_request_json(
            base_url, "/devices", token, timeout, verify, proxy,
            params={"page": 1, "limit": 1, "views": "ID", "async": "false"},
        )
        if resp is not None:
            return True, _rate_limit_from_resp(resp)
    except Exception:
        pass

    return False, data


# ---------------------------------------------------------------------
# Device fetch
# ---------------------------------------------------------------------
def get_devices(base_url: str, token: str, timeout: int,
                verify: bool, proxy: Optional[str]) -> Tuple[str, Optional[List[Dict[str, Any]]]]:
    devices: List[Dict[str, Any]] = []
    page = 1

    base_params = {
        "limit": 100,
        # "connected": "true",  # removed: we want disconnected devices, too
        "order": "ASC",
        "views": "FULL",
        "deviceTypes": "REAL",
        "async": "false",
    }

    while True:
        params = dict(base_params)
        params["page"] = page

        status, data_json, resp = api_request_json(
            base_url, "/devices", token, timeout, verify, proxy, params=params
        )

        if status == "RELOGIN":
            return "RELOGIN", None
        if status != "OK":
            return "ERROR", None

        chunk = data_json.get("data", []) if data_json else []
        if not chunk:
            break

        devices.extend(chunk)

        if len(chunk) < base_params["limit"]:
            break

        page += 1
        if page > 10000:
            break

    return "OK", devices


# ---------------------------------------------------------------------
# Radio information â€“ robust (with fallbacks)
# ---------------------------------------------------------------------
def _extract_radios_from_payload(payload: Any, device_id: Any) -> List[Dict[str, Any]]:
    """
    Accept both:
      - dict with "data": [{"device_id":..., "radios":[...]}]
      - plain list:       [{"device_id":..., "radios":[...]}]
    """
    did = str(device_id)
    radios: List[Dict[str, Any]] = []

    if not payload:
        return radios

    if isinstance(payload, dict) and isinstance(payload.get("data"), list):
        for entry in payload.get("data") or []:
            try:
                if str(entry.get("device_id")) == did:
                    radios.extend(entry.get("radios", []) or [])
            except Exception:
                continue
        if radios:
            return radios

    if isinstance(payload, list):
        for entry in payload:
            try:
                if str(entry.get("device_id")) == did:
                    radios.extend(entry.get("radios", []) or [])
            except Exception:
                continue

    return radios


def get_radio_information_for_device(
    base_url: str,
    token: str,
    timeout: int,
    verify: bool,
    proxy: Optional[str],
    device_id: int,
) -> List[Dict[str, Any]]:
    """
    Robust radio-information retrieval with multiple fallbacks:
      1) /devices/radio-information?deviceIds=<id>&page=1&limit=200&async=false
      2) /devices/radio-information?deviceIds=<id>&async=false
      3) /devices/<id>/radio-information?async=false
    """
    def _req(params=None, path="/devices/radio-information"):
        return api_request_json(
            base_url, path, token, timeout, verify, proxy,
            params=params or {},
        )

    # Try 1: paged
    status, payload, _ = _req(params={
        "deviceIds": str(device_id),
        "page": 1,
        "limit": 200,
        "async": "false",
    })
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    # Try 2: unpaged
    status, payload, _ = _req(params={
        "deviceIds": str(device_id),
        "async": "false",
    })
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    # Try 3: per-device path
    status, payload, _ = api_request_json(
        base_url, f"/devices/{device_id}/radio-information",
        token, timeout, verify, proxy, params={"async": "false"},
    )
    if status == "RELOGIN":
        return [{"_error": "RELOGIN"}]
    if status == "OK":
        radios = _extract_radios_from_payload(payload, device_id)
        if radios:
            return radios

    return []


# ---------------------------------------------------------------------
# Print rate-limit section
# ---------------------------------------------------------------------
def _print_rate_limits_section(rl_data: Dict[str, Any]) -> None:
    print("<<<extreme_cloud_iq_rate_limits:sep(124)>>>")

    state = rl_data.get("state") or "UNKNOWN"
    print(f"state|{state}")

    for key in ("limit", "remaining", "reset_in_seconds", "window_s", "status_code"):
        val = rl_data.get(key)
        if val is not None:
            print(f"{key}|{val}")

    if rl_data.get("error"):
        print(f"error|{rl_data['error']}")

    headers = rl_data.get("headers")
    if headers and isinstance(headers, dict):
        print("headers_begin|1")
        for hk, hv in headers.items():
            print(f"header|{hk}: {hv}")
        print("headers_end|1")


# ---------------------------------------------------------------------
# main()
# ---------------------------------------------------------------------
def main():
    args = parse_args()
    verify = not args.no_cert_check
    cachefile = _cache_path(args.host)

    # Token with cache
    token: Optional[str] = _cache_load(cachefile)
    if not token:
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            _print_rate_limits_section({"state": "NO_RESPONSE"})
            sys.exit(0)

    # Rate limits (with one-time re-login)
    ok_rl = False
    rl_data: Dict[str, Any] = {}
    try:
        ok_rl, rl_data = fetch_rate_limits(
            args.url, token, args.timeout, verify, args.proxy
        )
    except Exception as e:
        ok_rl, rl_data = False, {"state": "NO_RESPONSE", "error": str(e)}

    if not ok_rl:
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            ok_rl, rl_data = fetch_rate_limits(
                args.url, token, args.timeout, verify, args.proxy
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            _print_rate_limits_section({"state": "NO_RESPONSE"})
            sys.exit(0)

    _print_rate_limits_section(rl_data)

    # Fetch devices
    status, devices = get_devices(
        args.url, token, args.timeout, verify, args.proxy
    )
    if status == "RELOGIN":
        try:
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            status, devices = get_devices(
                args.url, token, args.timeout, verify, args.proxy
            )
        except Exception as e:
            print("<<<extreme_cloud_iq_login>>>")
            print(f"STATUS:FAILED CODE:ERROR RESPONSE:{e}")
            sys.exit(0)

    if status != "OK" or devices is None:
        print("<<<extreme_cloud_iq_login>>>")
        print("STATUS:FAILED CODE:ERROR RESPONSE:Device fetch failed")
        sys.exit(0)

    # Login OK marker
    print("<<<extreme_cloud_iq_login>>>")
    print("STATUS:OK CODE:200 RESPONSE:Token valid and data fetched")

    # -----------------------------------------------------------------
    # Piggyback: only APs AND managed_by == XIQ
    # -----------------------------------------------------------------
    ap_count = 0
    total_clients = 0
    sum_24 = 0
    sum_5  = 0
    sum_6  = 0

    for dev in devices:
        dev_fun_u = (str(dev.get("device_function", "")) or "").upper()
        managed_by_u = (str(dev.get("managed_by", "")) or "").upper()

        # Filter
        if dev_fun_u != "AP" or managed_by_u != "XIQ":
            continue

        # OPTIONAL: piggyback only if connected (uncomment to include disconnected)
        if not bool(dev.get("connected", False)):
            continue

        ap_count += 1

        hostname = dev.get("hostname") or dev.get("serial_number", "unknown")
        serial   = dev.get("serial_number", "")
        mac      = _format_mac(dev.get("mac_address", ""))
        ip       = dev.get("ip_address", "")
        model    = dev.get("product_type", "")
        sw       = dev.get("software_version") or dev.get("display_version") or ""
        connected = bool(dev.get("connected", False))
        uptime    = _safe_int(dev.get("system_up_time"), 0)

        # Locations: full + leaf
        locs = dev.get("locations") or []
        parts: List[str] = []
        for e in locs:
            if isinstance(e, str):
                parts.append(e.strip())
            elif isinstance(e, dict):
                n = e.get("name") or e.get("path") or ""
                if n:
                    parts.append(n.strip())
        full_location = " / ".join(p for p in parts if p)
        leaf_location = _shorten_location(locs)

        # LLDP short preview (clean)
        lldp_short = ""
        infos = dev.get("lldp_cdp_infos") or []
        if isinstance(infos, dict):
            infos = [infos]
        if infos:
            n0 = infos[0] or {}
            sysname = _clean_text(n0.get("system_name", "") or "")
            portid  = _clean_text(n0.get("port_id", "") or "")
            if sysname or portid:
                lldp_short = f"{sysname}/{portid}"

        # Band clients
        c24, c5, c6 = _band_clients(dev)
        total_clients += (c24 + c5 + c6)
        sum_24 += c24
        sum_5  += c5
        sum_6  += c6

        # --------------------------------------------------------
        # PIGGYBACK BLOCK START
        # --------------------------------------------------------
        print(f"<<<<{hostname}>>>>")

        # HOSTLABELS for piggyback host (JSON)
        print("<<<labels:sep(0)>>>")
        print(json.dumps({
            "xIq/device_type": "ap",
            "xIq/model": model,
            "xIq/location": leaf_location,  # short
            "xIq/connectivity": "CONNECTED" if connected else "DISCONNECTED",
        }, ensure_ascii=False))

        # HOSTATTRIBUTES for Smart Ping & rule targeting
        print("<<<cmk_host_attributes:sep(0)>>>")
        if ip:
            print(f"ipaddress={ip}")
        print(f"alias={hostname} (XIQ)")
        print("tag_piggyback=yes")
        print("tag_xiq_ap=yes")
        print(f"tag_Location={leaf_location}")  # fixed f-string

        # AP STATUS (now with FULL location in the field 10)
        print("<<<extreme_ap_status:sep(124)>>>")
        print(
            f"{hostname}|{serial}|{mac}|{ip}|{model}|"
            f"{1 if connected else 0}|"
            f"{'CONNECTED' if connected else 'DISCONNECTED'}|"
            f"{sw}|{uptime}|{full_location}|{lldp_short}"
        )

        # AP CLIENTS
        print("<<<extreme_ap_clients:sep(124)>>>")
        print(f"{c24}|{c5}|{c6}")

        # RADIO INFORMATION (robust) + SSID freq map
        radio_list = get_radio_information_for_device(
            args.url, token, args.timeout, verify, args.proxy, dev.get("id", 0)
        )

        if radio_list and isinstance(radio_list, list) and radio_list \
           and isinstance(radio_list[0], dict) and radio_list[0].get("_error") == "RELOGIN":
            # re-login
            token = api_login(
                args.url, args.username, args.password,
                args.timeout, verify, args.proxy, cachefile
            )
            radio_list = get_radio_information_for_device(
                args.url, token, args.timeout, verify, args.proxy, dev.get("id", 0)
            )

        ssid_freq: Dict[str, Dict[str, int]] = {}
        for r in (radio_list or []):
            freq = str(r.get("frequency") or "").strip()
            if not freq:
                mode = str(r.get("mode") or "").lower()
                if "5g" in mode:
                    freq = "5GHz"
                elif "6g" in mode:
                    freq = "6GHz"
                else:
                    freq = "2.4GHz"

            clients = r.get("clients") or []
            for c in clients:
                ssid = (c.get("ssid") or c.get("network_policy_name") or "").strip()
                if not ssid:
                    continue
                if ssid not in ssid_freq:
                    ssid_freq[ssid] = {"2.4GHz": 0, "5GHz": 0, "6GHz": 0}
                if freq in ssid_freq[ssid]:
                    ssid_freq[ssid][freq] += 1
                    
        # --------------------------------------------------------
        # AP NEIGHBORS (piggyback, full list for this AP)
        # --------------------------------------------------------
        
        print("<<<extreme_ap_neighbors:sep(124)>>>")
        neigh_list = dev.get("lldp_cdp_infos") or []
        if isinstance(neigh_list, dict):
            neigh_list = [neigh_list]

        for n in neigh_list:
            local_port    = _clean_text(n.get("interface_name", ""))
            remote_device = _clean_text(n.get("system_name", ""))
            management_ip = _clean_text(n.get("management_ip", ""))
            remote_port   = _clean_text(n.get("port_id", ""))
            port_desc     = _clean_text(n.get("port_description", ""))
            mac_address   = _format_mac(_clean_text(n.get("system_id", "")))

            # Format identisch zur H1-Section extreme_device_neighbors
            print(
                f"{dev.get('id','')}|{hostname}|{ip}|{local_port}|{management_ip}|"
                f"{remote_port}|{port_desc}|{mac_address}|{remote_device}"
            )

        print("<<<xiq_radio_information:json>>>")
        print(json.dumps({
            "device_id": dev.get("id"),
            "hostname": hostname,
            "radios": radio_list or [],
            "_ssid_freq": ssid_freq,
        }, ensure_ascii=False, separators=(",", ":")))

        print("<<<<>>>>")
        # --------------------------------------------------------
        # PIGGYBACK BLOCK END
        # --------------------------------------------------------

    # -----------------------------------------------------------------
    # SUMMARY (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_summary:sep(124)>>>")
    print(f"access_points|{ap_count}")
    print(f"total_clients|{total_clients}")
    print(f"clients_24|{sum_24}")
    print(f"clients_5|{sum_5}")
    print(f"clients_6|{sum_6}")

    # -----------------------------------------------------------------
    # DEVICE INVENTORY (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_device_inventory:sep(124)>>>")

    for dev in devices:
        dev_id     = dev.get("id", "")
        hostname   = dev.get("hostname") or dev.get("serial_number", "unknown")
        serial     = dev.get("serial_number", "")
        mac        = _format_mac(dev.get("mac_address", ""))
        ip         = dev.get("ip_address", "")
        model      = dev.get("product_type", "")
        sw         = dev.get("software_version") or dev.get("display_version") or ""
        dev_fun    = (dev.get("device_function", "") or "").upper() or "UNKNOWN"
        managed_by = dev.get("managed_by", "XIQ")
        connected  = bool(dev.get("connected", False))

        # full + leaf location
        locs = dev.get("locations") or []
        parts: List[str] = []
        for e in locs:
            if isinstance(e, str):
                parts.append(e.strip())
            elif isinstance(e, dict):
                n = e.get("name") or e.get("path") or ""
                if n:
                    parts.append(n.strip())

        full_location = " / ".join(p for p in parts if p)
        leaf_location = _shorten_location(locs)

        print(
            f"{dev_id}|{hostname}|{serial}|{mac}|{ip}|{model}|{sw}|"
            f"{full_location}|{dev_fun}|{managed_by}|{1 if connected else 0}"
        )

    # -----------------------------------------------------------------
    # LLDP/CDP NEIGHBORS (H1)
    # -----------------------------------------------------------------
    print("<<<extreme_device_neighbors:sep(124)>>>")

    for dev in devices:
        dev_id    = dev.get("id", "")
        hostname  = dev.get("hostname") or dev.get("serial_number", "unknown")
        host_ip   = dev.get("ip_address", "")

        neigh_list = dev.get("lldp_cdp_infos") or []
        if isinstance(neigh_list, dict):
            neigh_list = [neigh_list]

        for n in neigh_list:
            local_port    = _clean_text(n.get("interface_name", ""))
            remote_device = _clean_text(n.get("system_name", ""))
            management_ip = _clean_text(n.get("management_ip", ""))
            remote_port   = _clean_text(n.get("port_id", ""))
            port_desc     = _clean_text(n.get("port_description", ""))
            mac_address   = _format_mac(_clean_text(n.get("system_id", "")))

            print(
                f"{dev_id}|{hostname}|{host_ip}|{local_port}|{management_ip}|"
                f"{remote_port}|{port_desc}|{mac_address}|{remote_device}"
            )

    sys.exit(0)


if __name__ == "__main__":
    main()